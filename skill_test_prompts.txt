SOFA_MCP Skill Test Prompts

============================
Independent (single-skill)
============================

1) Start server
- I'm working on MCP, with @skills/sofa-mcp/sofa-mcp/SKILL.md as skill list, start mcp server
- "Start the SOFA MCP server and confirm it’s reachable. Don’t run any other tools yet."

2) Math sandbox
- "Use run_math_script to compute the diagonal length of the bbox with min=[-1,-2,-3], max=[4,5,6], and print the result."

3) Asset path resolution (exists)
- "Call resolve_asset_path on meshes/prostate.vtk and return the absolute path + existence."

4) Asset path resolution (missing)
- "Call resolve_asset_path on meshes/does_not_exist.vtk and clearly report the failure."

5) Mesh bounding box
- "Call get_mesh_bounding_box for meshes/prostate.vtk and report min/max."

6) Mesh topology
- "Call inspect_mesh_topology for meshes/prostate.vtk and report whether it’s surface/volumetric/unknown."

7) Mesh stats
- "Call mesh_stats for meshes/prostate.vtk and return bbox + counts + topology_kind."

8) Component search
- "Call search_sofa_components with query Tetra* (limit 20). If registry is unavailable, explain that and stop."

9) Component query
- "Call query_sofa_component for MechanicalObject and return its key info/fields."

10) Scene validation (minimal success)
- "Generate script_content that defines only add_scene_content(parent_node) and adds a MechanicalObject. Then call validate_scene and show stdout."

11) Scene validation (intentional failure)
- "Call validate_scene with a script_content that does NOT define add_scene_content. Confirm the error is surfaced cleanly."

12) Scene summary
- "Generate a minimal script_content that adds MechanicalObject, then call summarize_scene and report: node_count, object_count, mechanical_object_count, and the checks list."

13) Write scene
- "Generate a minimal script_content and call write_scene to write tmp_scene_written.py. Then call load_scene to confirm the file contains def createScene."

14) Load scene (missing)
- "Call load_scene on no_such_scene_file.py and confirm the tool returns a structured error."

15) Patch scene (insert)
- "Write a scene file tmp_patch_me.py using write_scene, then call patch_scene with an insert_after op anchored on def createScene(rootNode): to insert a comment line. Then load_scene and prove the comment exists."

16) Patch scene (anchor missing)
- "Call patch_scene on tmp_patch_me.py with an anchor string that doesn’t exist. Confirm it fails without corrupting the file (use load_scene before/after to compare)."

============================
Combined (2–3 skills)
============================

1) Mesh preflight -> math-derived scale
- "Use mesh_stats on meshes/prostate.vtk, then use run_math_script to compute a suggested scale = 1.0 / diagonal (guard if diagonal=0). Return the computed scale and bbox."

2) Component discovery -> confirm parameters
- "Use search_sofa_components for SparseLDL* (limit 10), pick the best match, then call query_sofa_component on that class and summarize what parameters look important."

3) Scene generation with asset preflight
- "First call resolve_asset_path + mesh_stats on meshes/prostate.vtk. Then generate a script_content that (a) adds a MechanicalObject, and (b) stores the resolved mesh path in a string variable (even if you don’t load it yet). Validate with validate_scene."

4) Validate -> summarize (structure gate)
- "Generate script_content that adds 2 MechanicalObjects in two different child nodes under parent_node. Run validate_scene, then summarize_scene, and verify mechanical_object_count >= 2."

5) Write -> load -> patch
- "Create script_content, write_scene to tmp_edit_flow.py, then load_scene to confirm it’s written. Then patch_scene to replace showBehaviorModels with showVisualModels in the file, and load_scene again to confirm the replacement."

============================
End-to-end (agentic workflows)
============================

1) Natural language -> validated scene file
- "I want a SOFA scene with a single particle at the origin, and nothing else fancy. Generate script_content, validate it, summarize it, then write it to out/scenes/particle_minimal.py."
- "generate a new particle.py, with two points at [0, 0, 1] and [0, 0, 2]. add gravity, and make the mechanical object visible "

2) Natural language -> validated scene file
- "I want a SOFA scene with a cantilever beam, fixed at one end, with gravity added. generate the scene, validate it, summarize and write it to cantilever_beam.py"

3) Natural language -> preflight mesh -> validated scene (stub)
- "Preflight the mesh (resolve path + stats) meshes/prostate.vtk, meshes/inner_*.stl. "
- "I want a SOFA scene with volumetric mesh as Tetrahedron element, fix at the bottom, validate, summarize and write to prostate.py"
- "based on prostate.py, add the independent internal chambers using meshes/inner_*.stl, internal chamber can be pressurized. then validate, summarize, write it to prostate_chamber.py if successful"

4) Natural language to edit a scene.
- "based on cantilever_beam.py, add a force at the free end of the beam for support. validate, summarize, write it to beam_support.py if successful"

5) Read the data
I'm working on MCP, with @skills/sofa-mcp/sofa-mcp/SKILL.md as skill list, start mcp server,
Use the run_and_extract tool on cantilever_base.py. Just give me the first 5 values of the tip displacement

6) Read the data and make adjust to match
I'm working on MCP, with @skills/sofa-mcp/sofa-mcp/SKILL.md as skill list, start mcp server,
I want to calibrate the cantilever_beam.py scene.
First, load the scene and get the node of the tip (free end) and remember.
Use run_and_extract to get the 'position' of the tip node over 1000 steps.
Calculate the tip vertical displacement.
If the displacement is greater than 10mm, use update_data_field to incresase the youngModulus of the FEM component to make it stiffer.
If it is less than 10mm, decrease the youngModulus.
Update youngModulus so that the displacement is close to 10mm (with tolerance of 0.1mm)
Run the extraction one more time after the update to confirm the new displacement.


7. Tests file storage & vertex selection
- "I want to test the simulation data workflow. Use the cantilever_beam.py scene. Run it for 200 steps with dt=0.01. Extract the position
  from the MechanicalObject in the scene. Once done, use process_simulation_data to give me the final position of only the vertex at index 0 and
  index 89."


8. Tests metrics & dimension handling
- "Run the cantilever_beam.py simulation for 1000 steps. Use process_simulation_data with calculate_metrics=True to analyze the results. Tell me:
  1. Did the beam reach a stable state (is it converged)?
  2. What was the maximum displacement magnitude observed for the whole beam?
  3. What is the net displacement vector for the first vertex in the mesh?"


8. Tests non-vector data handling
- "If the cantilever_beam.py has a mass component, extract the totalMass field for 10 steps. Then use process_simulation_data to check the
  peak_magnitude. This will verify that the tool handles scalar data correctly without crashing on vector-specific math."


9. Tests step slicing
- "Run a simulation of cantilever_beam.py for 50 steps. I only care about the transient behavior at the very beginning. Use
  process_simulation_data to extract only the first 5 steps of the position field."

10. Spatial Discovery & Targeted Stability
- "Find the indices of the fixed end of the beam (min X) from the latest simulation results. Then, use process_simulation_data to verify that
the max_displacement_magnitude for those specific indices is essentially zero."


11. High-Precision Tip Analysis
- "Identify all vertices at the very tip of the beam (max X). Use process_simulation_data on just the last index of that list to tell me the
stability_measure and whether that point has converged after 1000 steps."


12. Cross-Axis Boundary Check
- "Find the indices of the vertices on the 'bottom' edge of the beam (min Y). Run a 50-step simulation and show me the net_displacement_vector
for those indices to see how the bottom of the beam is compressing or stretching."


13. Parameter Sensitivity Test (The "Full Loop")
- "Use update_data_field to change the Young's Modulus (youngModulus) of the fem component in cantilever_beam.py to 500.0. Run it for 1000 steps,
find the tip indices, and tell me the final Y-displacement of the tip. Compare this to the ~14mm we saw earlier with the original modulus. then 
change the Young's Modulus back"


14. Memory Efficiency Test
- "Run the simulation for 500 steps. Use process_simulation_data with include_data=True for only vertex 89 and only steps 200 to 210. This
should return a tiny array even though the simulation is large."

15. The "Picky Component" Test 
- "Test the new query_sofa_component by querying TetrahedronFEMForceField. This component usually fails because it needs a specific plugin and a
  MechanicalObject to exist first. Verify that the tool now 'repairs' the query context and shows you the component's links and data fields
  anyway."


16. The "Lost MechanicalObject" Test
- "Generate a script_content where you add a MechanicalObject to the root node instead of the parent_node (e.g., parent_node.getRoot().addObject('MechanicalObject', name='ghost_mo')). Run summarize_scene and verify that health_warnings identifies it has no Solver in its ancestry."


17. The "ForceField Registry" Test 
- "Query the TetrahedronFEMForceField using query_sofa_component to confirm the repair logic works for introspection. Then, in a separate step, explain why summarize_scene fails on this component if dependencies are missing (it's a hard creation error in SOFA)."


18. The "Path Finder" Test 
- "Generate a complex scene with nested nodes (e.g., a 'prostate' node containing a 'surface' child node). Use summarize_scene to verify that
  every object now has an absolute Unix-style path (like /root/prostate/surface/mo)."

19. Simple Batch Plugin Discovery
- "I'm creating a basic SOFA scene and I plan to use MechanicalObject, UniformMass, and EulerImplicitSolver. What plugins do I need to import?"
- "I'm creating a basic SOFA scene and I plan to use SurfacePressureConstraint, SurfacePressureActuator. What plugins do I need to import?"
- Find the required plugins for `EulerImplicitSolver` and `AnisotropicForceField`. For this check, assume a context where a MechanicalObject
     templated on `Vec2d` is present.
- Get the required plugins for the following list of SOFA components: EulerImplicitSolver, CGLinearSolver, MechanicalObject, and
   TetrahedronFEMForceField.

20. Query with context
- Query the `HexahedronFEMForceField` component.
  (should observe an error message containing hints about missing topology)  -  no actually it just worked
- Query the `HexahedronFEMForceField` component, and ensure the context includes a `HexahedronSetTopologyContainer` named `my_hexa_topo`.

21. Query with context
- Query the `BeamFEMForceField` component. Use `Rigid3d` as the template and ensure the context includes a `MechanicalObject` named `mstate`
     with the `Rigid3d` template, and a `BeamAdapter` named `beam_adapter`.

22. Required plugin discovery
