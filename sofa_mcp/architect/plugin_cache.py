from __future__ import annotations

import json
import os
import sys
from typing import Dict

# Generated by a script, not checked into VC.
CACHE_FILENAME = ".sofa-component-plugin-map.json"


class suppress_stdout_stderr:
    """A context manager for suppressing stdout and stderr, including C-level output."""

    def __enter__(self):
        # Open a file to /dev/null
        self.null_fd = os.open(os.devnull, os.O_RDWR)
        
        # Save the original file descriptors
        self.old_stdout_fd = os.dup(1)
        self.old_stderr_fd = os.dup(2)
        
        # Redirect stdout and stderr to the null device
        os.dup2(self.null_fd, 1)
        os.dup2(self.null_fd, 2)

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Restore the original file descriptors
        os.dup2(self.old_stdout_fd, 1)
        os.dup2(self.old_stderr_fd, 2)
        
        # Close the saved file descriptors
        os.close(self.old_stdout_fd)
        os.close(self.old_stderr_fd)
        
        # Close the file descriptor for the null device
        os.close(self.null_fd)


def get_cache_path() -> str:
    """Returns the absolute path to the cache file in the project's temp dir."""
    # A bit of a hack: assume the temp dir is one level above the 'sofa_mcp' dir's parent
    # This is fragile but avoids needing to pass the temp_dir path all the way down.
    try:
        # __file__ is sofa_mcp/architect/plugin_cache.py
        architect_dir = os.path.dirname(os.path.abspath(__file__))
        sofa_mcp_dir = os.path.dirname(architect_dir)
        project_root = os.path.dirname(sofa_mcp_dir)
        temp_dir = os.path.join(project_root, ".sofa_mcp_results")
        if not os.path.exists(temp_dir):
            os.makedirs(temp_dir)
        return os.path.join(temp_dir, CACHE_FILENAME)
    except Exception:
        # Fallback to a location relative to the script if path logic fails
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), CACHE_FILENAME)


def load_plugin_map() -> Dict[str, str]:
    """Loads the component-to-plugin map from the JSON cache file."""
    cache_path = get_cache_path()
    if not os.path.exists(cache_path):
        return {}
    try:
        with open(cache_path, "r") as f:
            return json.load(f)
    except (IOError, json.JSONDecodeError):
        return {}


def generate_and_save_plugin_map() -> Dict[str, str]:
    """
    Scans SOFA's plugin directories to build a map of components to their plugins.

    This is a heavy operation and should only be run on demand.
    It works by finding all plugin libraries, loading them one by one, and
    checking which new components appear in the factory.
    """
    try:
        import SofaRuntime
        import Sofa.Core
        from . import factory_utils
    except ImportError:
        return {"error": "Sofa runtime not found."}

    plugin_map = {}
    sofa_root = os.environ.get("SOFA_ROOT")
    if not sofa_root:
        return {"error": "SOFA_ROOT environment variable is not set."}

    lib_paths = [os.path.join(sofa_root, "lib")]
    build_lib_path = os.path.join(sofa_root, "build", "lib")
    if os.path.exists(build_lib_path):
        lib_paths.append(build_lib_path)

    plugin_libs = []
    for path in lib_paths:
        if os.path.isdir(path):
            for f in os.listdir(path):
                if f.startswith("lib") and f.endswith(".so"):
                    plugin_name = f[len("lib") : -len(".so")]
                    # Exclude some problematic or irrelevant plugins
                    if any(
                        s in plugin_name
                        for s in ["SofaValidation", "SofaExporter", "SofaSimpleFem"]
                    ):
                        continue
                    plugin_libs.append(plugin_name)

    factory = factory_utils.get_object_factory_instance()
    
    for plugin_name in sorted(list(set(plugin_libs)), key=len, reverse=True):
        try:
            # Get components before loading
            before_components = set(factory_utils.collect_component_names_from_factory(factory))
            # Load the plugin
            with suppress_stdout_stderr():
                SofaRuntime.importPlugin(plugin_name)
            # Get components after loading
            after_components = set(factory_utils.collect_component_names_from_factory(factory))
            # The difference is the set of components from this plugin
            new_components = after_components - before_components
            for component in new_components:
                # Do not overwrite entries from more-specific plugins
                if component not in plugin_map:
                    plugin_map[component] = plugin_name
        except Exception:
            continue

    cache_path = get_cache_path()
    try:
        with open(cache_path, "w") as f:
            json.dump(plugin_map, f, indent=4)
    except IOError:
        return {"error": f"Failed to write plugin cache to {cache_path}"}

    return plugin_map

